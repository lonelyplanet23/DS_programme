### 错题解析：合并链表循环逻辑修正

---

#### **原错误代码**
```c
while (p != NULL && q != NULL) {
    if (p->data <= q->data) {
        r = r->link；  // ❌ 错误1：未先链接节点
        r = p；        // ❌ 错误2：指针跳跃导致链表断裂
        p = p->link；
    } else {
        r = r->link；
        r = q；        // ❌ 同上
        q = q->link；
    }
}
```
---
#### **核心错误点**
1. **链接顺序错误**  
   • **错误逻辑**：先移动`r`指针，再赋值`r = p/q`，导致**链表断裂**。  
   • **正确逻辑**：应先通过`r->link = p/q`将节点链接到结果链表尾部，再移动`r`指针。

2. **指针操作缺失**  
   • 未通过`r->link`建立节点间的链接关系，直接移动指针会导致已合并的链表失去后续节点。
---
#### **修正后代码**
```c
while (p != NULL && q != NULL) {
    if (p->data <= q->data) {
        r->link = p;  // ✅ 正确1：将p节点链接到链表尾部
        r = p;        // ✅ 正确2：移动r指针到新尾部
        p = p->link;  // ✅ p指针后移
    } else {
        r->link = q;  // ✅ 将q节点链接到链表尾部
        r = q;        // ✅ 移动r指针到新尾部
        q = q->link;  // ✅ q指针后移
    }
}
```

---

#### **图示说明**
```
初始状态：
listc → [1] -> [3] -> ... (lista)
p → [1]
q → [2] -> [4] -> ... (listb)
r → [1]

第一次循环（p.data=1 <= q.data=2）：
1. r->link = p → 保持链接（此时p已链接到r）
2. r = p → r移动到p的位置（即节点1）
3. p = p->link → p移动到节点3

最终效果：
listc → [1] -> [3]...  
r → [1]，p → [3]，q → [2]
```

---
