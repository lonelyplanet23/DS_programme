
### **双指针法求链表倒数第k个结点**
#### **题目要求**
1. 输入：链表头指针 `list`，整数 `k`  
2. 输出：倒数第k个结点的地址，若不存在则返回 `NULL`  
3. 限制：  
   • **不得求出链表长度**  
   • **只能使用O(1)额外空间**

---

#### **算法思路**
**双指针法（快慢指针）**  
1. **初始化快慢指针**：`fast` 和 `slow` 均指向头结点  
2. **快指针先走k步**：  
   • 若链表长度不足k，直接返回 `NULL`  
3. **同步移动双指针**：  
   • 当 `fast` 走到链表尾时，`slow` 指向倒数第k个结点  

---

#### **代码实现（修正版）**
```c
Nodeptr searchNode(Nodeptr list, int k) {
    // 边界条件：空链表或k<=0
    if (list == NULL || k <= 0) return NULL;

    Nodeptr fast = list, slow = list;
    
    // 快指针先走k-1步（到达第k个结点）
    for (int i = 0; i < k-1; i++) {
        if (fast->link == NULL) return NULL; // 链表长度不足k
        fast = fast->link;
    }

    // 同步移动双指针
    while (fast->link != NULL) {
        fast = fast->link;
        slow = slow->link;
    }
    
    return slow; // slow指向倒数第k个结点
}
```

---

#### **关键步骤图解**
```
原始链表：1 → 2 → 3 → 4 → 5 → NULL，k=3

Step 1: fast先走k-1=2步
slow        fast
 ↓           ↓
1 → 2 → 3 → 4 → 5 → NULL

Step 2: 同步移动直到fast到尾
           slow        fast
            ↓           ↓
1 → 2 → 3 → 4 → 5 → NULL

结果：slow指向结点3（倒数第3个结点）
```

---

#### **复杂度分析**
| 操作       | 时间复杂度 | 空间复杂度 |
|------------|------------|------------|
| 遍历链表   | O(n)       | O(1)       |

---

#### **常见错误分析**
1. **未处理k>链表长度**：  
   • 在快指针移动时需检查 `fast->link` 是否为 `NULL`  
2. **循环次数错误**：  
   • 快指针需移动 `k-1` 步（从第1个到第k个结点）  
3. **指针同步逻辑错误**：  
   • 必须保证快指针最终指向尾结点（而非尾结点的`link`）

---
