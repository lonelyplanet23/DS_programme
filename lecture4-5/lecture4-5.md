# lecture 4 线性表
---

## 线性表基础概念
### 定义
• **线性关系**：元素间呈"一对一"顺序关系，除首尾元素外每个元素有唯一前驱和后继
• **三特性**：同一性（同类型元素）、有穷性、有序性（逻辑顺序）

### 基本操作
```c
initList(list);      // 初始化空表
getNode(list, pos);  // 获取第pos个元素
insertNode(list, pos, node);  // 插入元素
deleteNode(list, pos);        // 删除元素
sortList(list);      // 排序
searchNode(list, key);       // 查找元素
```

---

## 顺序存储结构
### 构造原理
+ 连续内存空间存储元素
+ 线性表的一
+ 地址计算公式：`LOC(a_i) = LOC(a_1) + (i-1)*k`

### 核心操作
#### 1. 查找（折半查找）
```c
int BinarySearch(SqList L, ElemType key) {
  int low=0, high=L.length-1;
  while(low <= high) {
    int mid = (low+high)/2;
    if(L.data[mid] == key) return mid;
    else if(L.data[mid] > key) high = mid-1;
    else low = mid+1;
  }
  return -1;
}
```

#### 2. 插入
+ 需要将之后的元素后移，复杂度 O(N)
```c
Status ListInsert(SqList &L, int pos, ElemType e) {
  if(pos<1 || pos>L.length+1) return ERROR;
  if(L.length >= MAXSIZE) return ERROR;
  for(int j=L.length; j>=pos; j--)
    L.data[j] = L.data[j-1];
  L.data[pos-1] = e;
  L.length++;
  return OK;
}
```

#### 3. 删除
+ 同样需要将之后的元素前移 O(N)
```c
Status ListDelete(SqList &L, int pos) {
  if(pos<1 || pos>L.length) return ERROR;
  for(int j=pos; j<L.length; j++)
    L.data[j-1] = L.data[j];
  L.length--;
  return OK;
}
```

### 优缺点
| **优点** | **缺点** |
|---------|---------|
| 随机访问O(1) | 插入/删除O(n) |
| 存储密度高 | 预分配空间问题 |
| 适合静态数据 | 扩容困难 |

---

## 线性表排序算法
### 1. 插入排序
**核心思想**：构建有序序列，将未排序元素插入合适位置
**第i趟排序将未排序子序列（原始序列的后n-i个元素）的首元素插入到已排序子序列的正确位置**，使有序区长度+1  
```c
// 示例：第3趟排序（i=3）处理第4个元素
初始序列：[5, 3, 1, 4, 2]
第1趟后：[3, 5 | 1, 4, 2]  // 插入3到有序区
第2趟后：[1, 3, 5 | 4, 2]  // 插入1到有序区
第3趟后：[1, 3, 4, 5 | 2]  // 插入4到有序区
```
```c
void InsertSort(ElemType A[], int n) {
  for(int i=1; i<n; i++) {
    ElemType temp = A[i];
    int j = i-1;
    while(j>=0 && A[j]>temp) {
      A[j+1] = A[j];
      j--;
    }
    A[j+1] = temp;
  }
}
```
• **时间复杂度**：O(n²)（最优O(n)）
• **稳定性**：稳定

### 2. 选择排序
**核心思想**：每趟选最小元素交换到有序区末尾
**第i趟排序从未排序子序列（原始序列的后n-i+1个元素）中选择一个值最小的元素，将其与未排序序列的首元素交换位置**,使有序区长度+1
**选择排序法的元素之间的比较次数与原始序列中元素的分布状态无关,因此适合随机性比较大的数组**
```c
// 示例：第3趟排序（i=2）处理后3个元素（n-i+1=5-2+1=4）
原始序列：[3, 1, 5, 4, 2]
第1趟后：1 | [3, 5, 4, 2]  // 选出最小值1
第2趟后：1, 2 | [5, 4, 3]  // 从剩余4个元素中选最小值2
第3趟后：1, 2, 3 | [5, 4]  // 从剩余3个元素中选最小值3
```

```c
void SelectSort(ElemType A[], int n) {
  for(int i=0; i<n-1; i++) {
    int minIndex = i;
    for(int j=i+1; j<n; j++)
      if(A[j] < A[minIndex]) minIndex = j;
    Swap(A[i], A[minIndex]);
  }
}
```
• **时间复杂度**：O(n²)
• **稳定性**：不稳定

### 3. 冒泡排序
**核心思想**：相邻元素比较交换，每趟确定最大元素位置
**第i趟，是把第i大的元素冒上去**
```c
// 示例：第2趟排序处理前3个元素（n-i=5-2=3）
初始序列：[5, 3, 4, 1, 2]
第1趟后：[3, 4, 1, 2 | 5]  // 最大值5到达末尾
第2趟后：[3, 1, 2 | 4, 5]  // 次大值4到达倒数第二位
```
```c
void BubbleSort(ElemType A[], int n) {
  for(int i=0; i<n-1; i++) {
    bool flag = false;
    for(int j=0; j<n-i-1; j++)
      if(A[j] > A[j+1]) {
        Swap(A[j], A[j+1]);
        flag = true;
      }
    if(!flag) break;
  }
}
```
• **时间复杂度**：O(n²)（最优O(n)）
• **稳定性**：稳定

---
## 排序算法对比（统一视角）

| 算法         | 每趟操作目标                              | 未处理子序列范围       | 操作类型       |
|--------------|------------------------------------------|------------------------|----------------|
| **选择排序** | 选择最小值放入有序区末尾                 | 后n-i+1个元素          | 选择+交换      |
| **插入排序** | 将首元素插入到有序区正确位置             | 后n-i个元素            | 查找+移动      |
| **冒泡排序** | 通过相邻比较将最大值交换到未排序区末尾   | 前n-i个元素            | 比较+交换      |


---

## 核心总结
1. **统一规律**：所有简单排序算法都通过**逐步缩小未排序子序列范围**完成排序  
   • 选择排序：每趟减少1个未排序元素（选择最小值）  
   • 插入排序：每趟增加1个有序元素（插入正确位置）  
   • 冒泡排序：每趟确定1个最终位置（最大值沉底）  

2. **性能关键**：  
   ```math
   \text{总比较次数} = \sum_{i=1}^{n-1} (n-i) = \frac{n(n-1)}{2}
   ```
   （三种算法最坏情况下时间复杂度均为O(n²)）

3. **实战选择**：  
   • 数据基本有序 → **插入排序（递增，有时更优）/冒泡排序**（可接近O(n)）  
   • 数据随机分布 → **选择排序**（交换次数最少）  
   • 需要稳定性 → **插入/冒泡排序**
4. **稳定性的本质**
  + 在处理相等的值时，会不会改变二者的前后关系，选择排序中与首元素交换，可能会破坏
---
