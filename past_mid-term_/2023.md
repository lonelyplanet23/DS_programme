<h1 style="text-align: center"> 2023


## 选择题

1.若要删除非空线性链表中由 `p` 所指的链结点的直接后继链结点（由 `p->link` 指向），则需依次执行 __________。  

A. `r=p->link; p->link=r; free(r);` 

B. `r=p->link; p->link=r->link; free(r);`  

C. `r=p->link; p->link=r->link; free(p);` 

D. `p->link=p->link->link; free(p);` 

$\newline$

2.设某非空的单循环链表的头指针（指向第一个结点的指针）为`Head`，尾指针（指向最后一个结点的指针）为`Rear`，则下列条件判断结果一定为真的是 __________。  

A. `Head == Rear->link`   

B. `Head == Rear->link->link`   

C. `Rear == Head->link`   

D. `Rear == Head->link->link`   

$\newline$

3.若有语句 `int *point, a = 4;` 和 `point = &a;`，下面均代表地址的一组选项是 __________。  

A. a, point, *&a  

B. &(*a), &a, *point  

C. *(&point), *point, &a  

D. &a, &(*point), point  

$\newline$

4.若有以下说明和语句：  

```c
struct student { 
    int age; 
    int num; 
} std, *p; 
p = &std;
```

则以下对结构变量 `std` 中成员 `age` 的引用方式不正确的是 __________。  

A. `std.age`  

B. `p->age`  

C. `(*p).age`  

D. `*p.age`  

$\newline$

5.下列语句中，能正确进行字符串赋值的是 __________。  

A. `char s[10]; s="BUAA";` 

B. `char* sp; *sp="BUAA";` 

C. `char *sp="BUAA";`  

D. `char s[10]; *s="BUAA";` 

$\newline$

6.设 `p` 指针指向单链表（单链表长度为 `n`）中的某个结点（ `p≠NULL` ），若只知道指向该单链表第一个结点的指针和 `p` 指针，则在 `p` 指针所指结点之前和 `p` 指针所指结点之后插入一个结点的时间复杂度分别是 __________。  

A. `O(1)` 和 `O(n)`  

B. `O(1)` 和 `O(1)`   

C. `O(n)` 和 `O(n)`  

D. `O(n)` 和 `O(1)`  

$\newline$

7.若线性表最常用的运算是存取第 $\mathrm{i}$ 个元素及其前驱的值，则采用 __________。  

A. 单链表	B. 双链表	C. 顺序表	D. 循环单链表  

$\newline$

## 填空题

1.若有函数定义为  

```c
int func(int n) {
    if(n <= 1)
        return 1;
    else
        return (2 + n * func(n - 1));
}
```

假设 `m` 为 `int` 类型，则执行语句 `m = func(5);` 后，`m` 的值是 __________。  

  $\newline$

2.若有如下定义：

```c
char *pls[1000], buf[512];
int i = 0;
```

下面的语句是按行从标准输入读入一篇文章（每行字符数少于 511，行数少于 1000）保存到 `pls` 中，并且要求尽可能节省空间，请将语句补充完整：

```c
while (fgets(buf, 512, stdin) != NULL) {
    pls[i] = (char*)malloc(____________); // 补充完整此处代码
    strcpy(pls[i], buf);
    i++;
}
```

  $\newline$

3.有如下定义：

```c
struct point {
    float x, y;
};

struct triangle {
    struct point a, b, c;
} tr;
```

若要将三角形 tr 的顶点 b 的 x 坐标设置为 1.5，请将该赋值语句补充完整：

 __________ = 1.5;

$\newline$

## 编程题

### 1. 缩写字符串

**问题描述**  
输入一行字符串，将其中连续升序字符组成的子串改写成缩写格式输出，其他字符原样输出。这里的连续升序字符串是指后一字符的 ASCII 码值都比前一字符的 ASCII 码值大 1，并且要求：只有当子串中包含的连续字符个数大于等于 3 个时才进行缩写，否则不缩写。缩写格式由连续字符的第一个字符和最后一个字符之间添加一个英文减号字符“-”组成。例如：假如输入的一行字符串为 `The string is cdefjhijklmn.`，其缩写格式为 `The string is c-fjh-n.`。

**输入形式 **  
从控制台输入一行字符串，字符串中可能有空白符，行末有换行符（换行符不属于待缩写的字符串），字符串中的字符个数不会超过 100。

**输出形式**  
将缩写格式字符串输出到控制台，行末有无换行符均可。

**样例输入**  

```
The string is cdefjhijklmn.
```

**样例输出**  

```
The string is c-fjh-n.
```

**样例说明**  

输入的字符串中，子串 `st`  中 t 的 ASCII 码值虽然比 s 的 ASCII 码值大 1，但是连续字符的个数只有两个，所以不进行缩写；子串 `cdef` 含有四个字符，并且是连续升序的，所以缩写成 `c-f`，同理子串 `hijklmn` 缩写成 `h-n`。

$\newline$

### 2. 空闲空间申请模拟（首次适应）

**问题描述**   

在操作系统中，空闲存储空间通常以空闲块链表方式组织，每个块包含块起始位置、块长度及一个指向下一块的指针。空闲块按照**存储位置升序组织**，最后一块指向第一块（构成**循环链表**）。当有空间申请请求时，按照如下原则在空闲块循环链表中寻找并分配合适的空间：  

1. 从当前位置开始遍历空闲块链表（**初始时从地址最小的第一个空闲块开始**），寻找**第一个大于等于**请求空间的空闲块（即首次适应原则）。
2. 如果选择的空闲块恰好与请求的大小相符合，则将它从链表中移除并返回给用户；这时**当前位置变为被**移除的空闲块指向的**下一空闲块**。
3. 如果选择的空闲块大于所申请的空间大小，则将大小合适的空闲块返回给用户，剩下的部分留在空闲块链表中；这时**当前位置仍然为**该空闲块。
4. 如果找不到足够大的空闲块，则申请失败；这时**当前位置不变**。

例如：下图示例给出了空闲块链表的初始状态，每个结点表示⼀个空闲块，结点中上⾯的数字指空闲块的起始位置， 下⾯的数字指空闲块的⻓度，**位置和⻓度都⽤正整数表示，⼤⼩不超过 int 表示范围**。当前位置为最⼩地址为 1024 的空闲块。  

<img src="D:\BUAA_DB\img\2020_1.png" style="width: 50%;float: left;">

若有 4 个申请空间请求，申请的空间大小依次为：**1024**、**2560**、**10240** 和 **512**。则从当前位置开始遍历链表，按照上述原则寻找到满足条件的空闲块为地址是 **16384** 的空闲块，其长度正好为 **1024**，所以将其从链表中删除，这时链表状态如下图所示，当前位置变成地址为 **32768** 的空闲块。

<img src="D:\BUAA_DB\img\2020_2.png" style="width: 50%;float: left;">

从当前位置开始为第二个空间请求（大小为 **2560**）遍历链表，按照上述原则寻找到满足条件的空闲块为当前位置的空闲块，其长度为 **3072**，大于请求的空间大小。于是分配 **2560** 的空间后，该空闲块剩余的长度为 **512**，当前位置不变，链表状态如下图所示：

<img src="D:\BUAA_DB\img\2020_3.png" style="width: 50%;float: left;">

从当前位置开始为第三个空间请求（大小为 **10240**）遍历链表，遍历一圈后发现找不到足够大的空闲块，则忽略该请求，当前位置不变。下面继续为第四个空间请求（大小为 **512**）遍历链表，按照上述原则寻找到满足条件的空闲块仍然是当前位置的空闲块，其长度等于请求的空间大小，于是将该空闲块删除后，链表状态变为下图所示：

<img src="D:\BUAA_DB\img\2020_4.png" style="width: 50%;float: left;">

编写程序，模拟上述空闲空间申请。

**输入形式**  
先从控制台读入一正整数，表示当前空闲块的个数（大于0且小于等于100）。 

然后**按照起始位置由小到大**的顺序分行输入每个空闲块的起始位置和长度，**位置和长度都用正整数表示，大小不超过 int 表示范围，两整数间以一个空格分隔。** 

最后在新的一行上依次输入申请空间的大小，以 `-1` 表示结束，各整数间以一个空格分隔，申请请求的个数不超过 100 个。

**输出形式**  
按照上述原则模拟完空闲空间申请后，输出当前空闲空间链表状态，即**从当前位置开始**，遍历链表，**分行输出**剩余空闲块的起始位置和长度，位置和长度间以一个空格分隔。若申请完后，链表中没有空闲块，则什么都不输出。

**样例输入**  

```
12
1024 512
8192 512
16384 1024
32768 3072
65536 8192
77824 1024
80896 8192
96016 1024
101136 5120
119328 512
134448 1024
142640 3072
1024 2560 10240 512 2048 6400 2560 5600 2000 -1
```

**样例输出**  

```
101136 560
119328 512
134448 1024
142640 3072
1024 512
8192 512
65536 544
77824 1024
80896 1792
96016 1024
```

**样例说明**  

样例输入了 12 个空闲块的信息，形成了如上述第一个图所示的空闲块链表；然后读取了 9 个空间申请请求。为前 4 个请求分配空间后，空闲块链表状态为上述最后一张图所示。满足第五个请求后，地址为 **65536** 的空闲块剩余长度为 **6144**；满足第六个请求后，地址为 **80896** 的空闲块剩余长度为 **1792**；满足第七个请求后，地址为 **101136** 的空闲块剩余长度为 **2560**；满足第八个请求后，地址为 **65536** 的空闲块剩余长度为 **544**；满足第九个请求后，地址为 **101136** 的空闲块剩余长度为 **560**。这时链表中剩余 10 个空闲块，当前位置为地址是 **101136** 的空闲块，从该空闲块开始依次遍历输出所有剩余空闲块的起始位置和长度。

