<h1 style="text-align: center"> 2022

## 选择题

1.若有语句 `int *point, a = 4;` 和 `point = &a;`，下面均代表地址的一组选项是 __________。  

A. a, point, *&a  

B. &(*a), &a, *point  

C. *(&point), *point, &a  

D. &a, &(*point), point  

  $\newline$

2.若有以下说明和语句：  

```c
struct student { 
    int age; 
    int num; 
} std, *p; 
p = &std;
```

则以下对结构变量 `std` 中成员 `age` 的引用方式不正确的是 __________。  

A. `std.age`  

B. `p->age`  

C. `(*p).age`  

D. `*p.age`  

  $\newline$

3.设 `p` 指针指向单链表（单链表长度为 `n`）中的某个结点（ `p≠NULL` ），若只知道指向该单链表第一个结点的指针和 `p` 指针，则在 `p` 指针所指结点之前和 `p` 指针所指结点之后插入一个结点的时间复杂度分别是 __________。  

A. `O(1)` 和 `O(n)`  

B. `O(1)` 和 `O(1)`   

C. `O(n)` 和 `O(n)`  

D. `O(n)` 和 `O(1)`  

$\newline$

4.设某非空的单循环链表的头指针（指向第一个结点的指针）为`Head`，尾指针（指向最后一个结点的指针）为`Rear`，则下列条件判断结果一定为真的是 __________。  

A. `Head == Rear->link`   

B. `Head == Rear->link->link`   

C. `Rear == Head->link`   

D. `Rear == Head->link->link`   

  $\newline$

5.若要删除非空线性链表中由 `p` 所指的链结点的直接后继链结点（由 `p->link` 指向），则需依次执行 __________。  

A. `r=p->link; p->link=r; free(r);` 

B. `r=p->link; p->link=r->link; free(r);`  

C. `r=p->link; p->link=r->link; free(p);` 

D. `p->link=p->link->link; free(p);` 

  $\newline$

6.下列语句中，能正确进行字符串赋值的是 __________。  

A. `char s[10]; s="BUAA";` 

B. `char* sp; *sp="BUAA";` 

C. `char *sp="BUAA";`  

D. `char s[10]; *s="BUAA";` 

  $\newline$

1.若线性表最常用的运算是存取第 $\mathrm{i}$ 个元素及其前驱的值，则采用 __________ 存储方式节省时间。  

A. 单链表	B. 双链表	C. 顺序表	D. 循环单链表  

  $\newline$

## 填空题

1.若有函数定义为  

```c
int func(int n) {
    if(n <= 1)
        return 1;
    else
        return (2 + n * func(n - 1));
}
```

假设 `m` 为 `int` 类型，则执行语句 `m = func(5);` 后，`m` 的值是 __________。  

  $\newline$

2.若有如下定义：

```c
char *pls[1000], buf[512];
int i = 0;
```

下面的语句是按行从标准输入读入一篇文章（每行字符数少于 511，行数少于 1000）保存到 `pls` 中，并且要求尽可能节省空间，请将语句补充完整：

```c
while (fgets(buf, 512, stdin) != NULL) {
    pls[i] = (char*)malloc(____________); // 补充完整此处代码
    strcpy(pls[i], buf);
    i++;
}
```

  $\newline$

3.有如下定义：

```c
struct point {
    float x, y;
};

struct triangle {
    struct point a, b, c;
} tr;
```

若要将三角形 tr 的顶点 b 的 x 坐标设置为 1.5，请将该赋值语句补充完整：

 __________ = 1.5;

$\newline$

## 编程题

### 1. 密码对应表

**问题描述**  
有一种加密方法为：其使用一个字符串（可以含重复字母，字符个数不超过50）作为密钥。例如：若密钥字符串为 `Fea25Ther`，则需要**先将大写字母转换成小写字母**，**并去掉密钥单词中的非字母及重复字母**得到单词串 `feathr`，然后将其**反序**，最后将**字母表中的其它字母以反序追加到后面**：

```
r h t a e f z y x w v u s q p o n m l k j i g d c b
```

加密字母的对应关系如下：

```
a b c d e f g h i j k l m n o p q r s t u v w x y z
r h t a e f z y x w v u s q p o n m l k j i g d c b
```

编写程序根据输入的密钥，生成相应的密码对应表串。

**输入形式 **  
从标准输入读入密钥字符串（字符个数**不超过 50**，其中可包含**空白符或其它非字母字符**），末尾**有换行符（不属于密钥字符串）**。

**输出形式**  
先向控制台输出原字母表，然后在下一行输出生成的对应密码表。

**样例输入**  

```
Fea25Ther
```

**样例输出**  

```
abcdefghijklmnopqrstuvwxyz
rhtaefzyxwvusqponmlkjigdcb
```

**样例说明**  

输入的密钥字符串为 `Fea25Ther`，先将大写字母转换成小写字母，并去掉密钥单词中的非字母及重复字母得到单词串 `feathr`，然后将其反序，最后将字母表中的其它字母以反序追加到后面，便得到密码表。

$\newline$

### 2. 基于前移法的链表查找

**问题描述**  

链表结构存在一个严重不足，就是需要顺序查找才能找到所需要的元素，查找性能低。下面为一个改进链表查找效率的方法。

链表构造规则如下：

1. 初始时链表为空；
2. 若元素**不在链表中**，将其**加到链表尾**；
3. 若元素**在链表中**，则将该元素**移到链表头**（若元素已在链表头则不移动）。 

编写程序，对输入的一组整数，依次在上述规则构建的链表中查找每个整数。

假如依次输入了15个整数，分别为：-200 120 85 97 2900 85 696 -120 85 120 85 120 85 97 120，前五个数据输入后，构建的链表如下所示：

<img src="../../img/2022_1.png">

结点中前面的数据表示输入的整数，后面的数据是该整数的出现次数。输入第六个数据后，构建的链表如下所示：

<img src="../../img/2022_2.png">

所有整数输入完毕后，构建的链表如下所示：

<img src="../../img/2022_3.png">

**输入形式**  
先从控制台读取整数的个数 $\mathrm{n}$（$\mathrm{n \lt 0}$），然后在下一行输入 $\mathrm{n}$ 个整数，各整数间以一个空格分隔，输入的整数不会超过 `int` 的表示范围。

**输出形式**  
先输出创建链表时总的整数比较次数，然后依次分行输出链表中前五个整数及其出现次数（整数和出现次数间以一个空格分隔）；若链表中的结点个数少于五个，则按照实际结点个数输出。

**样例输入**  

```
15
-200 120 85 97 2900 85 696 -120 85 120 85 120 85 97 120
```

**样例输出**  

```
41
120 4
97 2
85 5
-200 1
2900 1
```

**样例说明**  

输入了 15 个整数；按照上述链表创建规则，输入第一个整数后，没有比较整数，这时总的比较次数为 0；输入第五个整数后，整数比较次数为 10；输入第六个整数后，整数比较次数为 13；所有整数输入完毕后，总的比较次数为 41，这时整数 120 位于链表头，出现了 4 次。

