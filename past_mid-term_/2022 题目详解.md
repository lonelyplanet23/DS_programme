<h1 style="text-align: center"> 2022 年期中题目详解

## 选择题

所有选择题都在 2020 期中也考过。

1.首先，在 `int *point, a = 4;` 语句中，定义了一个 `int` 类型的指针和一个 `int` 变量 `a`。在 `point = &a;` 中将 `point` 的值设成了变量 `a` 的地址。

然后介绍一下 C 语言中 `*` 和 `&` 符号的作用：

- `&`：逻辑运算符（按位与）；取地址符，`&a` 获得变量 `a` 的起始地址
- `*`：乘号；定义某一类型的指针，`int *point` 表示定义一个 `int` 类型的指针 `point`；解引用，如 `*point`，即从 `point` 指向的地址开始，取出四个字节，按照一个 `int` 来解释，获得一个 `int`（也就是给我一个地址，得到一个值）

可以看到，取地址和解引用是互逆的，即 `*(&a) = &(*a) = a`（虽然对于 int 变量 `a` 而言 `*a` 没有实际意义甚至是非法的，但是也符合语法，只是在逻辑上不对）。所以四个选项中：

- a（值）、point（地址）、*&a（值，相当于 a）
- &(\*a)（值，相当于 a）、&a（地址）、\*point（值，相当于 a）
- \*(&point)（地址，相当于 point）、*point（值）、&a（地址）
- &a（地址）、&(*point)（地址）、point（地址）

$\newline$

2.理解 `->` 运算符的作用，`->` 运算符实际上是一个简写形式，`p -> x` 等价于 `(*p).x`，也就是先解引用，再取出某字段。  

A 正确，直接通过结构变量，利用 `.` 运算符取出某结构成员。  

B 正确，利用某结构类型的指针变量，利用 `->` 运算符取出结构成员。  

C 正确，(*p) 相当于先获得某结构变量，再用 `.` 运算符取出某结构成员。  

D 不正确，因为 `.` 的优先级比 `*` 的优先级更高，所以会先执行 `p.x`，但是 `p` 是个指针，所以错误。  

$\newline$

3.参考`选择题-7`，选 D。  

$\newline$

4.只要提到循环链表，一定要知道一个关系：**尾结点的后继元素是头结点**。所以一定正确的选项是 A。

$\newline$

5.删除 `p` 的后继节点：让 `p` 指向后继节点的后继节点（相当于跳过后继节点了），然后释放原后继节点的空间。故 B 正确。  

$\newline$

6.A 选项体现了数组和指针的重要差别之一，数组名的值相当于数组的起始地址，在初始化的时候已经被确定，在后续过程中不可以被修改（即不可以有 `int a[10]; a = b`），但是指针可以（即可以有 `int *a; a = b`）。

B 选项中 `sp` 是一个 `char` 类型的指针，所以 `*sp` 得到的是一个 `char`，不能把一个地址赋值给一个 `char`（B 选项的关键在于理解 `*` 的含义）。  

C 选项正确，定义了一个 `char` 类型的指针，并把字符串常量 `BUAA` 的起始地址赋值给了这个指针。  

D 选项不正确，跟 B 一个问题。  

补充一下，对下面三行代码，都是字符串初始化，但是它们的行为不同：

```c
char s1[] = "BUAA";
char s2[10] = "BUAA";
char *s3 = "BUAA";
```

- 第一行代码先推导出数组大小应该为 `5`，然后再把几个字符依次拷贝进去（BUAA + 空字符）
- 第二行代码把 BUAA + 空字符拷贝到数组的前 5 个位置
- 第三个行代码先在只读数据区中给 "BUAA" 分配了一片空间，然后得到了一个起始地址，再把这个起始地址给 `s3` 

$\newline$

7.顺序存储与链式存储常用操作的时间复杂度比较：

<img src="D:\BUAA_DB\img\2020_5.png" style="width: 70%;">

存取第 $\mathrm{i}$ 个元素的值分为两步：找到第 $\mathrm{i}$ 个元素 $\mathrm{\rightarrow}$ 存取这个元素的值。存取其前驱元素（也就是第 $\mathrm{i - 1}$ 个元素）的值也是类似的，不过在找第 $\mathrm{i - 1}$ 个的时候可以利用已经找到的第 $\mathrm{i}$ 个元素，可能不需要从头开始找了。

四个选项各个操作的时间复杂度比较如下：

|                | 1. 找到第 i 个元素 | 2. 存取第 i 个元素的值 | 3. 找到第 i - 1 个元素                 | 4. 存储第 i - 1 个元素的值 |
| -------------- | ------------------ | ---------------------- | -------------------------------------- | -------------------------- |
| **单链表**     | O(n)               | O(1)                   | O(n) （还要从头开始找）                | O(1)                       |
| **双链表**     | O(n)               | O(1)                   | O(1) （直接访问第 i 个元素的前驱字段） | O(1)                       |
| **顺序表**     | O(1)               | O(1)                   | O(1)                                   | O(1)                       |
| **循环单链表** | O(n)               | O(1)                   | O(n) （还要从头开始找）                | O(1)                       |

综上，顺序表各个操作的效率最高。

$\newline$

## 填空题

1.自己编程运行一下或者手动模拟一下即可，答案为 `292`。

$\newline$

2.我们要在填的空上写一个长度，用来作为 `malloc` 的参数，开辟指定大小的空间来存储读入的 `buf`，而且还要尽可能小。开辟的新空间，要能容纳下 `buf` 包含的所有字符，同时还要留一个位置容纳一个空字符，如果没有空字符的话，可能把 `buf` 存进去后 `buf` 后面跟着的其它非空字符也会被当做 `buf` 的一部分，无法正确地拆分出 `buf`（这部分可以参考 `作业讲解/第四次作业/题面详解/D 字符串` 部分）。

所以要填 `strlen(buf) + 1`。

**当处理字符串的时候，千万要注意空字符**！

$\newline$

3.这里就是要了解一下结构体的成员可以是其它结构类型的变量。填 `tr.b.x`。

$\newline$

### 编程题

1.这道题简单来说分成两步：

- 读入字符串 `str`，对其进行预处理，然后逆转得到字符串 `rev` 
- 从 `a` 到 `z` 依次取出不在 `str` 中的字母，然后逆转后接在 `rev` 后面

我们可以用到头文件 `<ctype.h>`，这个头文件提供了很多字符判断或简单字符处理的方法（注意是字符，而不是字符串）。

同时我们还需要去掉 `str` 中的重复字母，记录哪些字母在 `str` 中出现过。这里我们可以使用惯用的简单哈希思想，用 `vis[i]` 标识字母 `i + 'a'` 是否出现过（比如 `vis[0]` 标识字母 `a` 是否出现过，`vis[1]` 标识字母 `b` 是否出现过，依次类推）。

第一步：

```c
scanf("%s", str);
int len = strlen(str);

for(int i = 0; i < len; i++) {
    // 如果是字母，而且之前没有出现过
    if(isalpha(str[i]) && !vis[str[i] - 'a']) {
        // 转换为对应的小写字母
        str[i] = tolower(str[i]);
        vis[str[i] - 'a'] = 1;
        rev[revLen++] = str[i];
    }
}
// 逆转
strrev(rev);
```

第二步：

```c
// 检查没出现过的字母
for(int i = 0; i < 26; i++) {
    if(!vis[i]) 
        tem[temLen++] = 'a' + i;
}
// 逆转后，接在 rev 的后面
strcat(rev, strrev(tem));
```

这道题的完整代码可以参考 `往年期中/参考代码/2022_1.c`。

$\newline$

2.简单来说，就是每次读入一个数字后，看看之前有没有出现过这个数字：如果有，就把对应的结点移动到链表头部；如果没有，就新建一个结点插入到链表尾部。其中维护总的比较次数、某数字出现过多少次之类的细节比较简单，我们不再赘述，只关注核心部分。

在这里我们使用**哑结点**的思想，创建两个虚拟的结点，作为链表的头结点和尾结点，以避免对头结点和尾结点进行特殊处理。什么意思呢？简单来说，就是假如我们按照正常的链表实现的话，在这个过程中需要维护 `head` 变量和 `tail` 变量，以指向链表的第一个节点和最后一个结点，方便在头部进行插入和删除。在这个过程中可能会有以下几个问题：

- 插入第一个节点时需要给 `head` 和 `tail` 赋值，也就是要特判 `head` 是否为空：

```c
if(head == NULL)
    head = tail = p;
```

- 在删除操作中，比如我们想删除结点 `p`，我们还要对 `p` 是不是头结点或尾结点进行特判，因为头结点不含有前驱元素（`head -> pre == NULL`），尾结点不含有后继元素（`tail -> nxt == NULL`）。同时，由于 `p` 作为头结点被删除了，那我们就要让 `p` 的后继成为新的头结点；尾结点的情况也类似。总的来说，删除结点的代码如下：

```c
void remove(nptr p) {
    if(head == tail) { // 特殊情况只有一个结点
        head = tail = NULL;
        free(p);
        return ;
    }

    if(p == head) { // 特殊情况 p 是头结点
        head = head -> nxt;
        head -> pre = NULL;
    }
    else if(p == tail) { // 特殊情况 p 是尾结点
        tail = tail -> pre;
        tail -> nxt = NULL;
    }
    else { // p 在中间的情况
        p -> pre -> nxt = p -> nxt;
        p -> nxt -> pre = p -> pre;
    }

    free(p);
}
```

我们思考，为什么会出现这样麻烦的问题——就是因为后面进来的结点可能作为头结点和尾结点，而头结点和尾结点不保证一定有前驱后继元素。所以，我们可以直接创建两个结点分别作为头结点和尾结点，后面插入进来的结点，一定在这两个结点之间，一定有前驱后继元素，就不需要特判了。同时，由于涉及到删除操作，所以维护一个双向链表更简单。也就是：

```c
nptr getnode(int val) {
    nptr p = newnode(); 
    p -> val = val;
    p -> cnt = 1;
    p -> pre = p -> nxt = NULL;
    return p;
}

void init() {
    // head 和 tail 是两个哑结点，占位用
    head = getnode(0);
    tail = getnode(0);
    // 维护前驱后继关系
    head -> nxt = tail;
    tail -> pre = head;
}
```

注意，虽然 `head = getnode(0);` 和 `tail = getnode(0);`，但是一定不能直接写 `head = tail = getnode(0)`。因为 `getnode` 返回一个 `malloc` 分配的空间的起始地址，第一种写法相当于两个不同的地址；第二种写法是两个同样的地址，那 `head` 和 `tail` 实际上就是一个结点了，最后两行代码就相当于你写：

```c
head -> pre = head;
head -> nxt = head;
```

这样就成环了，显然是不对的。

每次输入一个值，要查找这个值是否出现过，也就是遍历链表：

```c
// 查找值对应的结点
nptr find(int val) {
    // 注意：千万不要把 head 和 tail 算进去，它们是两个哑结点
    nptr p = head -> nxt;
    while(p != tail) {
        cmp_cnt++;
        if(p -> val == val)
            return p;
        p = p -> nxt;
    }
    return NULL;
}
```

主函数里，每次读入值后根据 `find` 的返回值执行对应的操作：

```c
int main() {
    ...
    for(int i = 1; i <= n; i++) {
        int r = readInt();
        nptr p = find(r);
        if(p == NULL) 
            insert_back(getnode(r));
        else if(p == head -> nxt)
            continue;
        else
            insert_front(p);
    }
    ...
}

```

如果结点之前不存在，就新创建一个结点并且插在尾部，这里的尾部也就是 `tail` 之前（因为 `tail` 是个哑结点，是占位用的，它永远都是尾部）。我们要修改 `tail` 前驱元素的 `nxt` 字段，`tail` 的 `pre` 字段，以及新节点本身的两个字段：

```c
void insert_back(nptr p) {
    // 无须特判
    tail -> pre -> nxt = p;
    p -> pre = tail -> pre;
    p -> nxt = tail;
    tail -> pre = p;
}
```

如果之前结点存在，那就把结点先从链表中移除，再插入到链表头部，跟 `insert_back` 大同小异：

```c
void insert_front(nptr p) {
    // 从链表中删除 p
    p -> pre -> nxt = p -> nxt;
    p -> nxt -> pre = p -> pre;

    // 重新插入 p
    head -> nxt -> pre = p;
    p -> nxt = head -> nxt;
    p -> pre = head;
    head -> nxt = p;
    
    // 维护值的出现次数
    p -> cnt += 1;
}
```

根据 `insert_front` 的实现，主函数找到输入值对应的结点后的第二个分支不写也行，也就是对应题面中**若元素已在链表头则不移动**的分支。因为即使 `p` 是第一个节点，我把它从链表中移出来重新放回去就可以了。可以这么写：

```c
if(p == NULL) 
	insert_back(getnode(r));
else
	insert_front(p);
```

最后再输出一下对应的值就可以了，输出值的时候别忘了千万要跳过哑头结点和哑尾结点。

这道题的完整代码可以参考 `往年期中/参考代码/2022_2.c`。