<h1 style="text-align: center"> 2023 年期中题目详解


## 选择题

所有选择题都在 2020 期中、2022 年期中也考过。

1.删除 `p` 的后继节点：让 `p` 指向后继节点的后继节点（相当于跳过后继节点了），然后释放原后继节点的空间。故 B 正确。  

$\newline$

2.只要提到循环链表，一定要知道一个关系：**尾结点的后继元素是头结点**。所以一定正确的选项是 A。

$\newline$

3.首先，在 `int *point, a = 4;` 语句中，定义了一个 `int` 类型的指针和一个 `int` 变量 `a`。在 `point = &a;` 中将 `point` 的值设成了变量 `a` 的地址。

然后介绍一下 C 语言中 `*` 和 `&` 符号的作用：

- `&`：逻辑运算符（按位与）；取地址符，`&a` 获得变量 `a` 的起始地址
- `*`：乘号；定义某一类型的指针，`int *point` 表示定义一个 `int` 类型的指针 `point`；解引用，如 `*point`，即从 `point` 指向的地址开始，取出四个字节，按照一个 `int` 来解释，获得一个 `int`（也就是给我一个地址，得到一个值）

可以看到，取地址和解引用是互逆的，即 `*(&a) = &(*a) = a`（虽然对于 int 变量 `a` 而言 `*a` 没有实际意义甚至是非法的，但是也符合语法，只是在逻辑上不对）。所以四个选项中：

- a（值）、point（地址）、*&a（值，相当于 a）
- &(\*a)（值，相当于 a）、&a（地址）、\*point（值，相当于 a）
- \*(&point)（地址，相当于 point）、*point（值）、&a（地址）
- &a（地址）、&(*point)（地址）、point（地址）

$\newline$

4.理解 `->` 运算符的作用，`->` 运算符实际上是一个简写形式，`p -> x` 等价于 `(*p).x`，也就是先解引用，再取出某字段。  

A 正确，直接通过结构变量，利用 `.` 运算符取出某结构成员。  

B 正确，利用某结构类型的指针变量，利用 `->` 运算符取出结构成员。  

C 正确，(*p) 相当于先获得某结构变量，再用 `.` 运算符取出某结构成员。  

D 不正确，因为 `.` 的优先级比 `*` 的优先级更高，所以会先执行 `p.x`，但是 `p` 是个指针，所以错误。  

$\newline$

5.A 选项体现了数组和指针的重要差别之一，数组名的值相当于数组的起始地址，在初始化的时候已经被确定，在后续过程中不可以被修改（即不可以有 `int a[10]; a = b`），但是指针可以（即可以有 `int *a; a = b`）。

B 选项中 `sp` 是一个 `char` 类型的指针，所以 `*sp` 得到的是一个 `char`，不能把一个地址赋值给一个 `char`（B 选项的关键在于理解 `*` 的含义）。  

C 选项正确，定义了一个 `char` 类型的指针，并把字符串常量 `BUAA` 的起始地址赋值给了这个指针。  

D 选项不正确，跟 B 一个问题。  

补充一下，对下面三行代码，都是字符串初始化，但是它们的行为不同：

```c
char s1[] = "BUAA";
char s2[10] = "BUAA";
char *s3 = "BUAA";
```

- 第一行代码先推导出数组大小应该为 `5`，然后再把几个字符依次拷贝进去（BUAA + 空字符）
- 第二行代码把 BUAA + 空字符拷贝到数组的前 5 个位置
- 第三个行代码先在只读数据区中给 "BUAA" 分配了一片空间，然后得到了一个起始地址，再把这个起始地址给 `s3` 

$\newline$

6.参考`选择题-7`，选 D。  

$\newline$

7.顺序存储与链式存储常用操作的时间复杂度比较：

<img src="D:\BUAA_DB\img\2020_5.png" style="width: 70%;">

存取第 $\mathrm{i}$ 个元素的值分为两步：找到第 $\mathrm{i}$ 个元素 $\mathrm{\rightarrow}$ 存取这个元素的值。存取其前驱元素（也就是第 $\mathrm{i - 1}$ 个元素）的值也是类似的，不过在找第 $\mathrm{i - 1}$ 个的时候可以利用已经找到的第 $\mathrm{i}$ 个元素，可能不需要从头开始找了。

四个选项各个操作的时间复杂度比较如下：

|                | 1. 找到第 i 个元素 | 2. 存取第 i 个元素的值 | 3. 找到第 i - 1 个元素                 | 4. 存储第 i - 1 个元素的值 |
| -------------- | ------------------ | ---------------------- | -------------------------------------- | -------------------------- |
| **单链表**     | O(n)               | O(1)                   | O(n) （还要从头开始找）                | O(1)                       |
| **双链表**     | O(n)               | O(1)                   | O(1) （直接访问第 i 个元素的前驱字段） | O(1)                       |
| **顺序表**     | O(1)               | O(1)                   | O(1)                                   | O(1)                       |
| **循环单链表** | O(n)               | O(1)                   | O(n) （还要从头开始找）                | O(1)                       |

综上，顺序表各个操作的效率最高。

$\newline$

## 填空题

所有填空题都在 2022 年期中也考过。

1.自己编程运行一下或者手动模拟一下即可，答案为 `292`。

$\newline$

2.我们要在填的空上写一个长度，用来作为 `malloc` 的参数，开辟指定大小的空间来存储读入的 `buf`，而且还要尽可能小。开辟的新空间，要能容纳下 `buf` 包含的所有字符，同时还要留一个位置容纳一个空字符，如果没有空字符的话，可能把 `buf` 存进去后 `buf` 后面跟着的其它非空字符也会被当做 `buf` 的一部分，无法正确地拆分出 `buf`（这部分可以参考 `作业讲解/第四次作业/题面详解/D 字符串` 部分）。

所以要填 `strlen(buf) + 1`。

**当处理字符串的时候，千万要注意空字符**！

$\newline$

3.这里就是要了解一下结构体的成员可以是其它结构类型的变量。填 `tr.b.x`。

$\newline$

### 编程题

1.我们又遇到了**字符串模式匹配**的问题，我们就不难想到**状态转移的思想**。如果你还不了解状态转移的思想，可以先去看一下**作业讲解-程序设计基础练习-题目讲解**中第五道题的题解，这里的处理是大同小异的，可以设下面几个状态：

- 0：正常状态，表示进行普通的处理
- 1：当前字符 = 前一字符 + 1，表示即将进入到省略状态
- 2：已经出现连续 3 个字符，表示进入到省略状态

状态转移的过程还是比较复杂的，因此我们在这里阐述一下各个状态之间如何进行转移，以及转移过程中应该执行的动作：

- 上一状态为 0：
  - 如果当前字符 = 上一字符 + 1，则转移到状态 1
  - 否则，直接输出当前字符
- 上一状态为 1：
  - 如果当前字符 = 上一字符 + 1，则输出一个 `-`，并转移到状态 2
  - 否则，不满足连续三个的条件，输出前一个字符和当前字符（这里输出前一个字符的原因是因为在 0 $\mathrm{\rightarrow}$ 1 的过程中我们并没有输出对应的字符，所以要在这里输出）
- 上一状态为 2：
  - 如果当前字符 = 上一字符 + 1，则保持在状态 2
  - 否则，退出省略状态，变回状态 0，并输出上一个字符和当前字符（因为上一个字符代表连续的结尾，这一个字符跟它不挨着，所以都要输出）

也就是：

```c
for(int i = 0; i < len; i++) {
    if(m == 0) {	// 状态 0
        if(i == 0 || str[i] != str[i - 1] + 1)
            printf("%c", str[i]);
        else
            m = 1;
    }
    else if(m == 1) {	// 状态 1
        if(str[i] == str[i - 1] + 1)
            printf("-"), m = 2;
        else
            printf("%c%c", str[i - 1], str[i]), m = 0;
    } else {		// 状态 2
        if(str[i] == str[i - 1] + 1)
            continue;
        else
            printf("%c%c", str[i - 1], str[i]), m = 0;
    }
}
```

最后，如果只这么写的话，如果输入直到最后都一直保持连续，那最后的字符不会输出（比如输入 `abcd`、 `ab` 或者 `aabc`）。所以我们还要在循环外进行特判，如果 `m` 不为 $0$，则说明到最后还一直连续，就应该输出最后一个字符：

```c
if(m != 0)
	printf("%c", str[len - 1]);
```

这道题的完整代码可以参考 `往年期中/参考代码/2023_1.c`。

$\newline$

2.这道题跟 `2020` 年期中一模一样。

这道题跟我们链表那次作业的第三题基本一样，就是把最佳适应策略换成了首次适应策略，感觉还更简单了。

首先不断地读入结点的位置和大小，创建一个链表。全部读入后，利用尾结点的后继是头结点，创建一个循环链表。

然后，每次读入一个空间，从当前位置，找首次适应这个空间的块，**把指定的空间分配出去，并更新当前位置**：

```c
// alloc 函数分配空间，并返回新的`当前位置`
while((sz = readInt()) != -1) 
	now = alloc(now, sz);
```

在 `alloc` 中，我们要从当前位置开始，遍历一圈链表，找到第一个 $\mathrm{\ge}$ 指定大小的结点。我们可以使用 `do while` 语句，其与 `while` 的区别仅仅在于 `do while` 至少会执行一次，这样我们就不用特判只有一个结点的情况了：

```c
nptr p = now, ret = NULL;
do {
    if(p -> sz >= sz) {
        ret = p;
        break;
    }
    p = p -> next;
} while(p != now);
```

当找到这个结点后，我们要根据这个结点的容量来进行后续处理。如果这个结点的容量刚好等于 `sz`，我们还要删除这个结点，由于涉及到了链表的删除操作，所以我们一开始可以维护一个双向链表（当需要删除时，最好再维护一下每个结点的前驱元素，这样就不用从头开始遍历了）：

```c
// alloc 函数的剩余部分

if(ret != NULL) {
    // 大小恰好相等，按照规则 2，移除该结点，并返回当前位置为下一空闲块
    if(ret -> sz == sz) {
        ret -> next -> prev = ret -> prev;
        ret -> prev -> next = ret -> next;
        if(ret -> next == ret)
            return NULL;
        return ret -> next;
    } else {
        // 大于申请空间，按照规则 3，修改 sz 字段即可，并返回当前位置为这个空闲块
        ret -> sz -= sz;
        return ret;
    }
}
// 没有合适大小的空闲块，按照规则 4，当前位置不变
return now;
```

这道题的完整代码可以参考 `往年期中/参考代码/2023_2.c`。